{"version":3,"sources":["../../src/config/theme.ts","../../src/shapes/Circle.ts","../../src/utils/getRandomColor.ts","../../src/tree/BinaryTreeNode.ts","../../src/tree/BinarySearchTreeNode.ts","../../src/tree/index.ts","../../src/utils/getRGBString.ts","../../src/helpers/ColorGenerator.ts","../../src/canvas/Canvas.ts","../../src/enumns/VisualizationType.ts","../../src/utils/tree.ts","../../src/strokes/BezierCurve.ts","../../src/utils/connectPointsWithBezierCurve.ts","../../src/canvas/drawPrettyBinaryTree.ts","../../src/canvas/drawExpandableBinaryTree.ts","../../src/canvas/drawSimpleBinaryTree.ts","../../src/canvas/drawBinaryTree.ts","../../src/canvas/index.ts","../../src/enumns/index.ts","../../src/config/index.ts","../src/index.ts","../src/app.js"],"names":["resultBtn","document","getElementById","nodesValues","result","querySelector","message","error","resetBtn","inputToList","e","preventDefault","value","style","display","innerText","data","split","list","forEach","values","push","parseInt","some","isNaN","innerHTML","hasDuplicates","buildATree","dupli","tellsDuplicates","elem","root","BinarySearchTreeNode","i","length","insert","set","Set","add","size","res","counts","num","key","Object","hasOwnProperty","call","textFont","radius","fontSize","strokeColor","colorArray","borderColor","bgColor","leafNodeSpace","lineHeight","addEventListener","window","matchMedia","matches"],"mappings":"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","file":"app.a0c42301.js","sourceRoot":"..\\public","sourcesContent":["import {Theme} from './types';\n\nconst theme: Theme = {\n  radius: 20,\n  growthAndShrinkTimes: 1.25,\n  leafNodeSpace: 75,\n  lineHeight: 90,\n  fontSize: 10,\n  textFont: 'Poppins',\n  strokeColor: '#f56042',\n  colorArray: [\n    {bgColor: '#fff2e0', borderColor: '#f56042'},\n  ],\n};\n\n/**\n * Set the user defined theme if required\n *\n * @param {Theme} userDefinedTheme\n */\nexport function setTheme(userDefinedTheme: Partial<Theme>) {\n  const {\n    radius = theme.radius,\n    growthAndShrinkTimes = theme.growthAndShrinkTimes,\n    leafNodeSpace = theme.leafNodeSpace,\n    lineHeight = theme.lineHeight,\n    colorArray = theme.colorArray,\n    textFont = theme.textFont,\n    strokeColor = theme.strokeColor,\n    fontSize = theme.fontSize,\n  } = userDefinedTheme;\n\n  theme.radius = radius;\n  theme.growthAndShrinkTimes = growthAndShrinkTimes;\n  theme.leafNodeSpace = leafNodeSpace;\n  theme.lineHeight = lineHeight;\n  theme.colorArray = colorArray;\n  theme.textFont = textFont;\n  theme.strokeColor = strokeColor;\n  theme.fontSize = fontSize;\n}\n\nexport default theme;\n\n","import {CanvasComponent} from '..';\nimport theme from '../config/theme';\nimport {CircleColorSettings} from '../config/types';\nimport {RadiusSettings} from './types';\n\n/**\n * Rate at which circle will grow or shrink\n */\nconst growthRate = 0.3;\n\n/**\n * Describes a circle in the canvas\n */\nclass Circle {\n  /**\n   * Radius of the circle\n   */\n  private radiusSettings: RadiusSettings\n\n  /**\n   * The colorId of the circle\n   */\n  private colorId: string = ''\n\n  /**\n   * Color of the circle\n   */\n  private colorSettings: CircleColorSettings\n\n  /**\n   * Value to be displayed inside the circle\n   */\n  private value: string\n\n  /**\n   * X Position of the circle\n   */\n  private x: number = -1\n\n  /**\n   * Y Position of the circle\n   */\n  private y: number = -1\n\n  /**\n   * For constructing a new circle\n   *\n   * @param {string} value\n   * @param {number} radius\n   * @param {CircleColorSettings} colorSettings\n   */\n  constructor(\n      value: string,\n      radius: number,\n      colorSettings: CircleColorSettings,\n  ) {\n    this.value = value;\n    this.colorSettings = colorSettings;\n    this.radiusSettings = {\n      currentRadius: radius,\n      originalRadius: radius,\n      maxRadius: radius * theme.growthAndShrinkTimes,\n      minRadius: radius / theme.growthAndShrinkTimes,\n    };\n  }\n\n  /**\n   * Draw the circle\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {number} radius\n   * @param {string} color\n   */\n  private drawCircle(\n      ctx: CanvasRenderingContext2D,\n      radius: number,\n      color: string,\n  ) {\n    const {x, y} = this;\n\n    ctx.beginPath();\n    ctx.fillStyle = color;\n    ctx.arc(x, y, radius, 0, Math.PI * 2, false);\n    ctx.fill();\n  }\n\n  /**\n   * Draw the border\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   */\n  private drawBorder(ctx: CanvasRenderingContext2D) {\n    const {x, y, colorSettings, radiusSettings: {currentRadius: radius}} = this;\n    const {borderColor} = colorSettings;\n\n    ctx.arc(x, y, radius, 0, Math.PI * 2, false);\n    ctx.strokeStyle = borderColor;\n    ctx.stroke();\n  }\n\n  /**\n   * Write the text\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   */\n  private writeText(ctx: CanvasRenderingContext2D) {\n    const {x, y, value, colorSettings} = this;\n    const {borderColor} = colorSettings;\n\n    // Decide font size\n    const fontSize = `${theme.fontSize}pt`;\n    const ySpacing = theme.fontSize/2;\n\n    ctx.fillStyle = borderColor;\n    ctx.font = `${fontSize} ${theme.textFont}`;\n    ctx.textAlign = 'center';\n    ctx.fillText(value, x, y + ySpacing);\n  }\n\n  /**\n   * Get the current radius\n   *\n   * @return {number}\n   */\n  getRadius() {\n    const {\n      radiusSettings: {currentRadius: radius},\n    } = this;\n    return radius;\n  }\n\n  /**\n   * Increase radius of the circle\n   * @param {number} maxRadius\n   * @return {boolean} - Weather size was changed\n   */\n  grow(maxRadius = this.radiusSettings.maxRadius) {\n    const {\n      radiusSettings: {\n        currentRadius,\n      },\n    } = this;\n\n    if (currentRadius < maxRadius) {\n      const originalIncreasedRadius = currentRadius + growthRate;\n      this.radiusSettings.currentRadius = originalIncreasedRadius > maxRadius ?\n      maxRadius : originalIncreasedRadius;\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Decrease the radius of the circle\n   * @param {number} minRadius\n   * @return {boolean} - Weather size was changed\n   */\n  shrink(minRadius = this.radiusSettings.minRadius) {\n    const {\n      radiusSettings: {\n        currentRadius,\n      },\n    } = this;\n\n    if (currentRadius > minRadius) {\n      const originalDecreasedRadius = currentRadius - growthRate;\n      this.radiusSettings.currentRadius = originalDecreasedRadius < minRadius ?\n      minRadius : originalDecreasedRadius;\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Bring the circle back to its original radius\n   * @return {boolean} - Weather size was changed\n   */\n  restoreCircle() {\n    const {\n      radiusSettings: {\n        currentRadius,\n        originalRadius,\n      },\n    } = this;\n\n    if (currentRadius > originalRadius) {\n      return this.shrink(originalRadius);\n    }\n\n    if (currentRadius < originalRadius) {\n      return this.grow(originalRadius);\n    }\n\n    return false;\n  }\n\n  /**\n   * Set the color id of the circle\n   *\n   * @param {string} colorId\n   */\n  setColorId(colorId: string) {\n    this.colorId = colorId;\n  }\n\n  /**\n   * Set the x and y coordinates of the circle\n   *\n   * @param {number} x\n   * @param {number} y\n   */\n  setCoordinates(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n\n  /**\n   * Draw the circle on the screen\n   * Draw the border\n   * Add the text\n   *\n   * @param {CanvasComponent} comp\n   * @return {string} - The color id represented by the unique color\n   */\n  draw(comp: CanvasComponent) {\n    const {\n      radiusSettings: {currentRadius: radius},\n      colorSettings: {bgColor},\n    } = this;\n\n    // Draw circle\n    this.colorId = this.colorId ? this.colorId : comp.getNextColor();\n    this.drawCircle(\n        comp.getContext(),\n        radius,\n        bgColor,\n    );\n    this.drawCircle(\n        comp.getHitContext(),\n        radius,\n        this.colorId,\n    );\n\n    // Draw border\n    this.drawBorder(comp.getContext());\n\n    // Write text\n    this.writeText(comp.getContext());\n\n    // Return the colorId\n    return this.colorId;\n  }\n}\n\nexport default Circle;\n","import {CircleColorSettings} from '../config/types';\nimport theme from '../config/theme';\n\n/**\n * Get a random color settings\n *\n * @return {CircleColorSettings}\n */\nfunction getRandomColor():CircleColorSettings {\n  const {colorArray} = theme;\n  return colorArray[Math.floor(Math.random() * colorArray.length)];\n}\n\nexport default getRandomColor;\n","import Circle from '../shapes/Circle';\nimport theme from '../config/theme';\nimport getRandomColor from '../utils/getRandomColor';\n\n/**\n * Describes a node of a binary tree\n */\nclass BinaryTreeNode<T extends string | number> {\n  /**\n   * The value of the node\n   */\n  value: T\n\n  /**\n   * The canvas circle\n   */\n  nodeCircle: Circle\n\n  /**\n   * The left child of the node\n   */\n  left?: BinaryTreeNode<T>\n\n  /**\n   * The right child of the node\n   */\n  right?: BinaryTreeNode<T>\n\n  /**\n   * For constructing a new binary tree node\n   *\n   * @param {T} value\n   */\n  constructor(value: T) {\n    this.value = value;\n    this.nodeCircle = new Circle(\n        `${value}`,\n        theme.radius,\n        getRandomColor(),\n    );\n  }\n\n  /**\n   * Set the left child\n   *\n   * @param {BinaryTreeNode} value\n   */\n  setLeft(value: BinaryTreeNode<T>) {\n    this.left = value;\n  }\n\n  /**\n   * Set the right child\n   *\n   * @param {BinaryTreeNode} value\n   */\n  setRight(value: BinaryTreeNode<T>) {\n    this.right = value;\n  }\n\n  /**\n   * Get the height of the binry tree from the node\n   * Height of root is 1\n   *\n   * @return {number}\n   */\n  getHeight():number {\n    const leftHeight = this.left?.getHeight() || 0;\n    const rightHeight = this.right?.getHeight() || 0;\n    return Math.max(leftHeight, rightHeight) + 1;\n  }\n}\n\nexport default BinaryTreeNode;\n","import BinaryTreeNode from './BinaryTreeNode';\n\n/**\n * A Binary search tree node\n */\nclass BinarySearchTreeNode<T extends string | number>\n  extends BinaryTreeNode<T> {\n    /**\n     * Left child of the node\n     */\n    left?: BinarySearchTreeNode<T>\n\n    /**\n     * Right child of the node\n     */\n    right?: BinarySearchTreeNode<T>\n\n    /**\n     * Set the left child of the node\n     *\n     * @param {BinarySearchTreeNode<T>} value\n     */\n    setLeft(value: BinarySearchTreeNode<T>) {\n      super.setLeft(value);\n    }\n\n    /**\n     * Set the right child of the node\n     *\n     * @param {BinarySearchTreeNode<T>} value\n     */\n    setRight(value: BinarySearchTreeNode<T>) {\n      super.setRight(value);\n    }\n\n    /**\n     * Insert a value into the node\n     * (Using Recursion)\n     *\n     * @param {T} value\n     */\n    insert(value: T) {\n      // Skip equal value\n      if (value === this.value) {\n        return;\n      }\n\n      // When value is lesser\n      if (value < this.value) {\n        if (this.left) {\n          this.left.insert(value);\n          return;\n        }\n        this.setLeft(new BinarySearchTreeNode(value));\n        return;\n      }\n\n      // When value is greater\n      if (this.right) {\n        this.right.insert(value);\n        return;\n      }\n      this.setRight(new BinarySearchTreeNode(value));\n    }\n\n    /**\n     * Find the minimum value from the given node\n     *\n     * @param {BinarySearchTreeNode<T>} node\n     * @return {BinarySearchTreeNode<T>}\n     */\n    findMinimum():BinarySearchTreeNode<T> {\n      if (this.left) {\n        return this.left.findMinimum();\n      }\n      return this;\n    }\n\n    /**\n     * Delete this node\n     *\n     * @param {BinarySearchTreeNode<T>} parent\n     * @return {[\n     *  BinarySearchTreeNode<T>,\n     *  BinarySearchTreeNode<T>\n     * ]} [deletedNode, currentRoot]\n     */\n    deleteThisNode(\n        parent?: BinarySearchTreeNode<T>,\n    ): [BinarySearchTreeNode<T>?, BinarySearchTreeNode<T>?] {\n      // Which direction is this node from the parent\n      const childDirection = parent?.left === this ? 'left' : 'right';\n\n      // Case 1: Delete leaf node\n      if (!this.left && !this.right) {\n        if (parent) {\n          delete parent[childDirection];\n        }\n        return [this];\n      }\n\n      // Case 2: Delete when there is only one child\n      if (this.left && !this.right) {\n        if (parent) {\n          parent[childDirection] = this.left;\n        }\n        return [this, this.left];\n      } else if (this.right && !this.left) {\n        if (parent) {\n          parent[childDirection] = this.right;\n        }\n        return [this, this.right];\n      }\n\n      // Case 3: There are 2 children\n\n      // Step 1: Delete the in order successor\n      const [deletedNode] = this.right!.delete(\n        this.right!.findMinimum().value, this,\n      );\n\n      // Step 2: Set the in order successor as the current node\n      // Deleted node will always be found\n      deletedNode!.left = this.left;\n      deletedNode!.right = this.right;\n      if (parent) {\n        parent[childDirection] = deletedNode;\n      }\n\n      return [this, deletedNode];\n    }\n\n    /**\n     * Delete a node\n     * (Using recursion)\n     *\n     * @param {T} value\n     * @param {BinarySearchTreeNode<T>} parent\n     * @return {[\n     *  BinarySearchTreeNode<T>,\n     *  BinarySearchTreeNode<T>\n     * ]} [deletedNode, currentRoot]\n     */\n    delete(\n        value: T,\n        parent?: BinarySearchTreeNode<T>,\n    ): [BinarySearchTreeNode<T>?, BinarySearchTreeNode<T>?] {\n      // Delete from left node\n      if (value < this.value && this.left) {\n        const [deletedNode] = this.left.delete(value, this);\n        return [deletedNode, this];\n      }\n\n      // Delete from right node\n      if (value > this.value && this.right) {\n        const [deletedNode] = this.right.delete(value, this);\n        return [deletedNode, this];\n      }\n\n      // Delete the current node\n      if (this.value === value) {\n        const res = this.deleteThisNode(parent);\n        delete this.left;\n        delete this.right;\n        return res;\n      }\n\n      return [, this];\n    }\n}\n\nexport default BinarySearchTreeNode;\n","import BinaryTreeNode from './BinaryTreeNode';\nimport BinarySearchTreeNode from './BinarySearchTreeNode';\n\nexport {\n  BinaryTreeNode,\n  BinarySearchTreeNode,\n};\n","/**\n * Get RGB string from red green and blue values\n *\n * @param {number} red\n * @param {number} green\n * @param {number} blue\n * @return {string}\n */\nfunction getRGBString(red: number, green: number, blue: number) {\n  return `rgb(${red}, ${green}, ${blue})`;\n}\n\nexport default getRGBString;\n","import getRGBString from '../utils/getRGBString';\n\n/**\n * The gap between 2 ids\n */\nconst gap = 10;\n\n/**\n * For generating color\n */\nclass ColorGenerator {\n  /**\n   * The red color value\n   */\n  private red = 0\n\n  /**\n   * The green color value\n   */\n  private green = 0\n\n  /**\n   * The blue color value\n   */\n  private blue = 1\n\n  /**\n   * Increment a color\n   *\n   * @param {'red' | 'green' | 'blue'} color\n   */\n  incrementColor(color: 'red' | 'green' | 'blue') {\n    this[color] = (this[color] + gap) % 256;\n  }\n\n  /**\n   * Get the next color\n   * Starts from rgb(0, 0, 0)\n   *\n   * @return {string}\n   */\n  getNextColor() {\n    // Generate the rgb value\n    const color = getRGBString(this.red, this.green, this.blue);\n\n    // Increment the color\n    this.incrementColor('blue');\n    if (this.blue < gap) {\n      this.incrementColor('green');\n      if (this.green < gap) {\n        this.incrementColor('red');\n      }\n    }\n\n    // Return the color\n    return color;\n  }\n}\n\nexport default ColorGenerator;\n","import ColorGenerator from '../helpers/ColorGenerator';\nimport getRGBString from '../utils/getRGBString';\nimport {GetColorCallBack} from './types';\n\n/**\n * Defines one canvas\n */\nclass CanvasComponent {\n  /**\n   * The canvas element\n   */\n  private $el: HTMLCanvasElement\n\n  /**\n   * This is a hidden canvas element\n   * which is used to redraw all the elements from the canvas\n   * in unique colors.\n   *\n   * This way an element can be easily identified from this hit canvas\n   * just by using the color in O(1)\n   *\n   * Otherwise to identify an element in the canvas it will take O(n)\n   *\n   */\n  private $hitEl: HTMLCanvasElement\n\n  /**\n   * The color generator for generating new color\n   */\n  private colorGenerator: ColorGenerator\n\n  /**\n   * The current hovering color\n   */\n  private currentHoveringColor: string = ''\n\n  /**\n   * For constructing a new canvas component\n   *\n   * @param {HTMLCanvasElement} $el\n   */\n  constructor($el: HTMLCanvasElement) {\n    const $hitEl = document.createElement('canvas');\n\n    this.$el = $el;\n    this.$hitEl = $hitEl;\n    this.colorGenerator = new ColorGenerator();\n  }\n\n  /**\n   * Clears the canvas\n   */\n  clearCanvas() {\n    const {height, width} = this.$el;\n    this.getContext().clearRect(0, 0, width, height);\n  }\n\n  /**\n   * Set the maximum width and height\n   *\n   * @param {number} height\n   * @param {number} width\n   */\n  setMaxWidthAndHeight(height: number, width: number) {\n    this.$hitEl.height = this.$el.height = height;\n    this.$hitEl.width = this.$el.width = width;\n  }\n\n  /**\n   * Get the hit 2d context\n   *\n   * @return {CanvasComponent}\n   */\n  getHitContext(): CanvasRenderingContext2D {\n    const ctx = this.$hitEl.getContext('2d');\n    if (!ctx) {\n      throw new Error('Cannot get 2d context');\n    }\n\n    return ctx;\n  }\n\n  /**\n   * Get the 2d context\n   *\n   * @return {CanvasRenderingContext2D}\n   */\n  getContext(): CanvasRenderingContext2D {\n    const ctx = this.$el.getContext('2d');\n    if (!ctx) {\n      throw new Error('Cannot get 2d context');\n    }\n\n    return ctx;\n  }\n\n  /**\n   * Get the next color from the color generator\n   *\n   * @return {string}\n   */\n  getNextColor() {\n    return this.colorGenerator.getNextColor();\n  }\n\n  /**\n   * On hover get the canvas hit color\n   *\n   * @param {GetColorCallBack} cb\n   */\n  onHover(cb: GetColorCallBack) {\n    this.$el.addEventListener('mousemove', (event) => {\n      const {pageX, pageY} = event;\n      const {data: pixel} = this.getHitContext().getImageData(\n          pageX - this.$el.offsetLeft,\n          pageY - this.$el.offsetTop,\n          1, 1,\n      );\n\n      // Callback should only be called on color change\n      const color = getRGBString(pixel[0], pixel[1], pixel[2]);\n      if (this.currentHoveringColor !== color) {\n        this.currentHoveringColor = color;\n        cb(color);\n      }\n    });\n  }\n\n  /**\n   * On click of canvas get the hit color\n   *\n   * @param {GetColorCallBack} cb\n   */\n  onClick(cb: GetColorCallBack) {\n    this.$el.addEventListener('click', (event) => {\n      const {pageX, pageY} = event;\n      console.log(pageX, pageY);\n      const {data: pixel} = this.getHitContext().getImageData(\n          pageX - this.$el.offsetLeft,\n          pageY - this.$el.offsetTop,\n          1, 1,\n      );\n      cb(getRGBString(pixel[0], pixel[1], pixel[2]));\n    });\n  }\n}\n\nexport default CanvasComponent;\n\n\n","export enum VisualizationType {\n  SIMPLE,\n  PRETTY,\n  EXPANDABLE,\n  HIGHLIGHT\n}\n","import theme from '../config/theme';\n\n/**\n * Get the max number of leaf nodes from height of the binary tree\n *\n * @param {number} treeHeight - Height of the tree (number of nodes from)\n * @return {number} - Maximum number of leaf nodes\n */\nexport function getMaxLeafNodesFromHeight(treeHeight: number) {\n  return 2 ** (treeHeight-1);\n}\n\n/**\n * Maximum canvas width required from number of tree nodes\n *\n * @param {number} maxNodes - Maximum number of nodes\n * @return {number} - The max width required\n */\nexport function getCanvasWidthFromMaxNodeSpacing(maxNodes: number) {\n  return (maxNodes + 2) * theme.leafNodeSpace;\n}\n\n/**\n * Get the x position from given horizontal node position\n *\n * @param {number} nodes - The number of nodes from the left\n * @return {number} - The x position\n */\nexport function getXPositionFromGivenHorizontalNodePosition(nodes: number) {\n  return (nodes) * theme.leafNodeSpace;\n}\n\n/**\n * Get canvas height from the tree height\n *\n * @param {number} treeHeight - Height of the tree (number of nodes from)\n * @return {number} - The canvas height in px\n */\nexport function getCanvasHeightFromTreeHeight(treeHeight: number) {\n  return (treeHeight) * theme.lineHeight;\n}\n\n/**\n * Get required and actual height and width\n *\n * @param {number} maxNodeSpacing\n * @param {number} heightOfTree\n * @param {number} maxWidth\n * @param {number} maxHeight\n * @return {{\n *  maxCanvasHeightRequired: number,\n *  maxCanvasWidthRequired:number,\n *  actualMaxHeight: number,\n *  actualMaxWidth: number\n * }}\n */\nexport function getRequiredAndActualHeightAndWidth(\n    maxNodeSpacing: number,\n    heightOfTree: number,\n    maxWidth: number,\n    maxHeight: number,\n) {\n  const maxCanvasWidthRequired = getCanvasWidthFromMaxNodeSpacing(\n      maxNodeSpacing,\n  );\n  const maxCanvasHeightRequired = getCanvasHeightFromTreeHeight(heightOfTree+1);\n  const actualMaxWidth = maxCanvasWidthRequired > maxWidth ?\n    maxCanvasWidthRequired : maxWidth;\n  const actualMaxHeight = maxCanvasHeightRequired > maxHeight ?\n    maxCanvasHeightRequired : maxHeight;\n\n  return {\n    maxCanvasHeightRequired,\n    maxCanvasWidthRequired,\n    actualMaxHeight,\n    actualMaxWidth,\n  };\n}\n","import {Point} from '../types/Point';\n\n/**\n * Describes a bezier curve\n */\nclass BezierCurve {\n  /**\n   * X Configurations\n   */\n  xStart: number\n  cp1x: number\n  cp2x: number\n  xEnd: number\n\n  /**\n   * Y Configurations\n   */\n  yStart: number\n  cp1y: number\n  cp2y: number\n  yEnd: number\n\n  /**\n   * Color of the curve\n   */\n  color: string\n\n  /**\n   * Construct a new bezier curve\n   *\n   * @param {string} color\n   * @param {Point} start\n   * @param {Point} cp1\n   * @param {Point} cp2\n   * @param {Point} end\n   */\n  constructor(\n      color: string,\n      start: Point,\n      cp1: Point,\n      cp2: Point,\n      end: Point,\n  ) {\n    const {x: xStart, y: yStart} = start;\n    const {x: cp1x, y: cp1y} = cp1;\n    const {x: cp2x, y: cp2y} = cp2;\n    const {x: xEnd, y: yEnd} = end;\n\n    this.color = color;\n    this.xStart = xStart;\n    this.yStart = yStart;\n    this.cp1x = cp1x;\n    this.cp1y = cp1y;\n    this.cp2x = cp2x;\n    this.cp2y = cp2y;\n    this.xEnd = xEnd;\n    this.yEnd = yEnd;\n  }\n\n  /**\n   * Draw the bezier curve\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   */\n  draw(ctx: CanvasRenderingContext2D) {\n    ctx.beginPath();\n    ctx.moveTo(this.xStart, this.yStart);\n    ctx.strokeStyle = this.color;\n    ctx.bezierCurveTo(\n        this.cp1x,\n        this.cp1y,\n        this.cp2x,\n        this.cp2y,\n        this.xEnd,\n        this.yEnd,\n    );\n    ctx.stroke();\n  }\n}\n\n\nexport default BezierCurve;\n","import CanvasComponent from '../canvas/Canvas';\nimport theme from '../config/theme';\nimport BezierCurve from '../strokes/BezierCurve';\nimport {\n  HorizontalStartAndEndInput,\n  VerticalStartAndEndInput,\n} from '../canvas/types';\n\n/**\n * Connect two points with a bezier curve\n *\n * @param {CanvasComponent} canvasComponent\n * @param {HorizontalStartAndEndInput} horizontalConfig\n * @param {VerticalStartAndEndInput} verticalConfig\n */\nfunction connectPointsWithBezierCurve(\n    canvasComponent: CanvasComponent,\n    horizontalConfig: HorizontalStartAndEndInput,\n    verticalConfig: VerticalStartAndEndInput,\n) {\n// X, Y Calculation\n  const {xStart, xEnd} = horizontalConfig;\n  const {yStart, yEnd} = verticalConfig;\n  const halfY = (yStart + yEnd) / 2;\n  const halfX = (xStart + xEnd) / 2;\n\n  // Draw the bezier curve\n  const berzierCurve = new BezierCurve(\n      theme.strokeColor,\n      {x: xStart, y: yStart},\n      {x: halfX, y: halfY},\n      {x: xEnd, y: halfY},\n      {x: xEnd, y: yEnd},\n  );\n  berzierCurve.draw(canvasComponent.getContext());\n}\n\nexport default connectPointsWithBezierCurve;\n","import {CanvasComponent} from '.';\nimport theme from '../config/theme';\nimport BinaryTreeNode from '../tree/BinaryTreeNode';\nimport {Point} from '../types/Point';\nimport {\n  getCanvasHeightFromTreeHeight,\n  getRequiredAndActualHeightAndWidth,\n  getXPositionFromGivenHorizontalNodePosition,\n} from '../utils/tree';\nimport connectPointsWithBezierCurve\n  from '../utils/connectPointsWithBezierCurve';\nimport {\n  IndividualInputOptions,\n  LeftAndRightSpacing,\n} from './types';\n\n/**\n * The current animation frame that is going on\n */\nlet animationFrameId: number;\n\n/**\n * Current color that is being hovered on\n */\nlet hoveredColorId: string;\n\n/**\n * Spacing map for storing space requirements\n */\nlet spacingMap: Map<BinaryTreeNode<string | number>, LeftAndRightSpacing>;\n\n/**\n * Clear the existing animation frame if any and request an animation frame\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} canvasComponent\n * @param {Point} position\n * @param {boolean} highlightMode\n */\nfunction requestAnimationFrame(\n    root: BinaryTreeNode<string | number>,\n    canvasComponent: CanvasComponent,\n    position: Point,\n    highlightMode: boolean,\n) {\n  // Clear existing animation frame\n  if (animationFrameId) {\n    cancelAnimationFrame(animationFrameId);\n  }\n\n  // Request a new one\n  animationFrameId = window.requestAnimationFrame(() => {\n    canvasComponent.clearCanvas();\n    const requiredRedraw = recursivelyDrawNodes(\n        root, canvasComponent, position, highlightMode);\n    if (requiredRedraw) {\n      requestAnimationFrame(root, canvasComponent, position, highlightMode);\n    }\n  });\n}\n\n/**\n * Draw single node\n *\n * @param {BinaryTreeNode} node\n * @param {CanvasComponent} comp\n * @param {Point} position\n * @param {boolean} highlightMode\n * @return {boolean} Weather redraw is required\n */\nfunction drawSingleNode(\n    node: BinaryTreeNode<string | number>,\n    comp: CanvasComponent,\n    position: Point,\n    highlightMode: boolean,\n) {\n  const {x, y} = position;\n  node.nodeCircle.setCoordinates(x, y);\n\n  // Grow or shrink while hover\n  const colorId = node.nodeCircle.draw(comp);\n  if (colorId === hoveredColorId && highlightMode) {\n    return node.nodeCircle.grow();\n  } else {\n    return node.nodeCircle.restoreCircle();\n  }\n}\n\n/**\n * Recursively draw all the nodes for a pretty tree\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} canvasComponent\n * @param {Point} position\n * @param {boolean} highlightMode\n * @return {boolean}\n */\nfunction recursivelyDrawNodes(\n    root: BinaryTreeNode<string | number>,\n    canvasComponent: CanvasComponent,\n    position: Point,\n    highlightMode: boolean,\n): boolean {\n  const {x: xPosition, y: yPosition} = position;\n\n  // Draw the node\n  let requiredRedraw = drawSingleNode(\n      root,\n      canvasComponent,\n      {x: xPosition, y: yPosition},\n      highlightMode,\n  );\n  root.nodeCircle.setCoordinates(xPosition, yPosition);\n  root.nodeCircle.draw(canvasComponent);\n\n  // Root spacings\n  const {left, right} = spacingMap.get(root)!;\n\n  // Draw the left child\n  if (root.left) {\n    const leftOfLeft = spacingMap.get(root.left)!.left;\n    const childYPosition = yPosition + theme.lineHeight;\n    const leftPosition = {\n      x: xPosition - getXPositionFromGivenHorizontalNodePosition(\n          left - leftOfLeft,\n      ),\n      y: childYPosition,\n    };\n\n    requiredRedraw = recursivelyDrawNodes(\n        root.left,\n        canvasComponent,\n        leftPosition,\n        highlightMode,\n    ) || requiredRedraw;\n    connectPointsWithBezierCurve(canvasComponent, {\n      xStart: xPosition,\n      xEnd: leftPosition.x,\n    }, {\n      yStart: yPosition + root.nodeCircle.getRadius(),\n      yEnd: childYPosition - root.left.nodeCircle.getRadius(),\n    });\n  }\n\n  // Draw the right child\n  if (root.right) {\n    const rightOfRight = spacingMap.get(root.right)!.right;\n    const childYPosition = yPosition + theme.lineHeight;\n    const rightPosition = {\n      x: xPosition + getXPositionFromGivenHorizontalNodePosition(\n          right - rightOfRight,\n      ),\n      y: childYPosition,\n    };\n\n    requiredRedraw = recursivelyDrawNodes(\n        root.right,\n        canvasComponent,\n        rightPosition,\n        highlightMode,\n    ) || requiredRedraw;\n    connectPointsWithBezierCurve(canvasComponent, {\n      xStart: xPosition,\n      xEnd: rightPosition.x,\n    }, {\n      yStart: yPosition + root.nodeCircle.getRadius(),\n      yEnd: childYPosition - root.right.nodeCircle.getRadius(),\n    });\n  }\n\n  return requiredRedraw;\n}\n\n/**\n * Calculates the spacing required recursively\n *\n * @param {BinaryTreeNode<string | number>} root\n * @return {number} - The spacing requirement of that node\n */\nfunction calculateSpacingMapRecursively(\n    root: BinaryTreeNode<string | number>,\n): number {\n  const left = root.left ? calculateSpacingMapRecursively(\n      root.left,\n  ) + 0.5: 0;\n  const right = root.right ? calculateSpacingMapRecursively(\n      root.right,\n  ) + 0.5: 0;\n  spacingMap.set(root, {\n    left,\n    right,\n  });\n\n  return left + right;\n}\n\n/**\n * Draw a pretty binary tree\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {HTMLCanvasElement} canvasElement\n * @param {IndividualInputOptions} options\n */\nfunction drawPrettyBinaryTree(\n    root: BinaryTreeNode<string | number>,\n    canvasElement: HTMLCanvasElement,\n    options: IndividualInputOptions,\n) {\n  spacingMap = new Map();\n  const maxNodeSpacing = calculateSpacingMapRecursively(root);\n  const heightOfTree = root.getHeight();\n  const {maxHeight, maxWidth, highlightMode} = options;\n\n  // Calculate canvas spacing requirements\n  const {\n    maxCanvasWidthRequired,\n    actualMaxHeight,\n    actualMaxWidth,\n  } = getRequiredAndActualHeightAndWidth(\n      maxNodeSpacing,\n      heightOfTree,\n      maxWidth,\n      maxHeight,\n  );\n\n  // Init calculation\n  const left = spacingMap.get(root)!.left;\n  const midPointInCanvas = actualMaxWidth / 2;\n  const xStart = (midPointInCanvas - maxCanvasWidthRequired / 2);\n\n  // Initialize the canvas\n  const canvasComponent = new CanvasComponent(canvasElement);\n  canvasComponent.setMaxWidthAndHeight(actualMaxHeight, actualMaxWidth);\n\n  /**\n   * Hover event handler\n   */\n  canvasComponent.onHover((color) => {\n    hoveredColorId = color;\n    requestAnimationFrame(root, canvasComponent, {\n      x: xStart + getXPositionFromGivenHorizontalNodePosition(left+1),\n      y: getCanvasHeightFromTreeHeight(0.5),\n    }, Boolean(highlightMode));\n  });\n\n  // Recursively draw all nodes\n  requestAnimationFrame(root, canvasComponent, {\n    x: xStart + getXPositionFromGivenHorizontalNodePosition(left+1),\n    y: getCanvasHeightFromTreeHeight(0.5),\n  }, Boolean(highlightMode));\n}\n\nexport default drawPrettyBinaryTree;\n","import {CanvasComponent} from '.';\nimport theme from '../config/theme';\nimport BinaryTreeNode from '../tree/BinaryTreeNode';\nimport {Point} from '../types/Point';\nimport {\n  getCanvasHeightFromTreeHeight,\n  getCanvasWidthFromMaxNodeSpacing,\n  getXPositionFromGivenHorizontalNodePosition,\n} from '../utils/tree';\nimport {IndividualInputOptions, PathArray} from './types';\nimport connectPointsWithBezierCurve\n  from '../utils/connectPointsWithBezierCurve';\n\n/**\n * The current animation frame that is going on\n */\nlet animationFrameId: number;\n\n/**\n * Array of all children that needs printing\n */\nlet globalPathArray: PathArray;\n\n/**\n * Current color that is being hovered on\n */\nlet hoveredColorId: string;\n\n/**\n * Map storing the colorId to the path array\n */\nlet colorIdToPathMap: Map<string, PathArray> = new Map();\n\n/**\n * Clear the existing animation frame if any and request an animation frame\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} comp\n * @param {IndividualInputOptions} options\n */\nfunction requestAnimationFrame(\n    root: BinaryTreeNode<string | number>,\n    comp: CanvasComponent,\n    options: IndividualInputOptions,\n) {\n  // Clear existing animation frame\n  if (animationFrameId) {\n    cancelAnimationFrame(animationFrameId);\n  }\n\n  // Request a new one\n  animationFrameId = window.requestAnimationFrame(\n      () => animationFrameCB(root, comp, options),\n  );\n}\n\n\n/**\n * Get the node height from print array\n *\n * @return {number}\n */\nfunction getNodeHeightFromGlobalPathArray() {\n  return globalPathArray.length + 1;\n}\n\n\n/**\n * Get the node width from the print array\n *\n * @return {{\n *  left: number,\n *  right: number\n * }}\n */\nfunction getNodeWidthFromGlobalPathArray() {\n  let left = 0;\n  let right = 0;\n  let current = 0;\n\n  for (const childDirection of globalPathArray) {\n    if (childDirection === 'left') {\n      current -= 1;\n    } else {\n      current += 1;\n    }\n    if (current < 0) {\n      left = Math.max(Math.abs(current), left);\n    } else {\n      right = Math.max(current, right);\n    }\n  }\n\n  return {\n    left, right,\n  };\n}\n\n/**\n * Draw single node\n *\n * @param {BinaryTreeNode} node\n * @param {CanvasComponent} comp\n * @param {PathArray} pathArray\n * @param {Point} position\n * @return {boolean} Weather redraw is required\n */\nfunction drawSingleNode(\n    node: BinaryTreeNode<string | number>,\n    comp: CanvasComponent,\n    pathArray: PathArray,\n    position: Point,\n) {\n  const {x, y} = position;\n  const doesNodeHaveChildren = Boolean(node.left || node.right);\n  node.nodeCircle.setCoordinates(x, y);\n\n  // Grow or shrink while hover\n  const colorId = node.nodeCircle.draw(comp);\n  colorIdToPathMap.set(colorId, pathArray);\n  if (colorId === hoveredColorId && doesNodeHaveChildren) {\n    return node.nodeCircle.grow();\n  } else {\n    return node.nodeCircle.restoreCircle();\n  }\n}\n\n/**\n * Draw both the children if required\n *\n * @param {BinaryTreeNode} node\n * @param {CanvasComponent} comp\n * @param {number} xPosition\n * @param {number} nodeHeight\n * @param {PathArray} pathArray\n * @return {boolean}\n */\nfunction drawChildren(\n    node: BinaryTreeNode<string | number>,\n    comp: CanvasComponent,\n    xPosition: number,\n    nodeHeight: number,\n    pathArray: PathArray,\n) {\n  const currentHeight = getCanvasHeightFromTreeHeight(nodeHeight);\n  const childHeight = getCanvasHeightFromTreeHeight(nodeHeight + 1);\n  let requiredRedraw = false;\n\n  // Draw the left child\n  if (node.left) {\n    const currentPathArray : PathArray = node.left.left || node.left.right ?\n      [...pathArray, 'left'] : [...pathArray];\n    const xLeft = xPosition - (0.5 * theme.leafNodeSpace);\n\n    requiredRedraw = drawSingleNode(\n        node.left,\n        comp,\n        currentPathArray, {\n          x: xLeft,\n          y: childHeight,\n        },\n    ) || requiredRedraw;\n    connectPointsWithBezierCurve(comp, {\n      xStart: xPosition,\n      xEnd: xLeft,\n    }, {\n      yStart: currentHeight + node.nodeCircle.getRadius(),\n      yEnd: childHeight - node.left.nodeCircle.getRadius(),\n    });\n  }\n\n  // Draw the right child\n  if (node.right) {\n    const currentPathArray : PathArray = node.right.left || node.right.right ?\n      [...pathArray, 'right'] : [...pathArray];\n    const xRight = xPosition + (0.5 * theme.leafNodeSpace);\n\n    requiredRedraw = drawSingleNode(\n        node.right,\n        comp,\n        currentPathArray, {\n          x: xRight,\n          y: childHeight,\n        },\n    ) || requiredRedraw;\n    connectPointsWithBezierCurve(comp, {\n      xStart: xPosition,\n      xEnd: xRight,\n    }, {\n      yStart: currentHeight + node.nodeCircle.getRadius(),\n      yEnd: childHeight - node.right.nodeCircle.getRadius(),\n    });\n  }\n\n  return requiredRedraw;\n}\n\n\n/**\n * Draw all the nodes by following print array\n *\n * @param {BinaryTreeNode} root\n * @param {CanvasComponent} comp\n * @param {number} xRootPosition\n * @return {boolean} - Weather animated redraw is required\n */\nfunction drawAllNodes(\n    root:BinaryTreeNode<string | number>,\n    comp: CanvasComponent,\n    xRootPosition: number): boolean {\n  // Draw root\n  let currentNode = root;\n  let xPosition = xRootPosition;\n  let currentNodeHeight = 0.5;\n  const currentPathArray: Array<'left' | 'right'> = [];\n  let requiredRedraw = drawSingleNode(root, comp, [...currentPathArray], {\n    x: xPosition,\n    y: getCanvasHeightFromTreeHeight(currentNodeHeight),\n  });\n\n  // Draw all the children according to the path\n  for (const currentPath of globalPathArray) {\n    requiredRedraw = drawChildren(\n        currentNode,\n        comp,\n        xPosition,\n        currentNodeHeight,\n        currentPathArray,\n    ) || requiredRedraw;\n\n    if (currentPath === 'left') {\n      currentNode = currentNode.left!;\n      xPosition = xPosition - (0.5 * theme.leafNodeSpace);\n      currentPathArray.push('left');\n    } else {\n      currentNode = currentNode.right!;\n      xPosition = xPosition + (0.5 * theme.leafNodeSpace);\n      currentPathArray.push('right');\n    }\n    currentNodeHeight += 1;\n  }\n\n  // Draw the children of the last element in the path\n  requiredRedraw = drawChildren(\n      currentNode,\n      comp,\n      xPosition,\n      currentNodeHeight,\n      currentPathArray,\n  ) || requiredRedraw;\n\n  // Return if redraw is required\n  return requiredRedraw;\n}\n\n/**\n * Animation frame call back function that will recursively be called.\n * In case animation is required\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} comp\n * @param {IndividualInputOptions} options\n */\nfunction animationFrameCB(\n    root: BinaryTreeNode<string | number>,\n    comp: CanvasComponent,\n    options: IndividualInputOptions,\n) {\n  // Height and width calculations\n  const nodeHeight = getNodeHeightFromGlobalPathArray();\n  const {\n    left: leftNodeWidth,\n    right: rightNodeWidth,\n  } = getNodeWidthFromGlobalPathArray();\n  const requiredHeight = getCanvasHeightFromTreeHeight(nodeHeight + 1);\n  const requiredWidth = getCanvasWidthFromMaxNodeSpacing(\n      leftNodeWidth+rightNodeWidth,\n  );\n  const actualHeight = Math.max(requiredHeight, options.maxHeight);\n  const actualWidth = Math.max(requiredWidth, options.maxWidth);\n  const xStart = (actualWidth/2) - (requiredWidth/2);\n\n  // Set the height and width\n  // This also clears the canvas. So no need to clear it manually.\n  comp.setMaxWidthAndHeight(actualHeight, actualWidth);\n\n  // Initialize color id to path map\n  colorIdToPathMap = new Map();\n\n  // Draw and check if redraw is required\n  const requiredRedraw = drawAllNodes(\n      root,\n      comp,\n      xStart + getXPositionFromGivenHorizontalNodePosition(leftNodeWidth + 1),\n  );\n  if (requiredRedraw) {\n    requestAnimationFrame(root, comp, options);\n  }\n}\n\n/**\n * Draw an expandable binary tree\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {HTMLCanvasElement} canvasElement\n * @param {IndividualInputOptions} options\n */\nfunction drawExpandableBinaryTree(\n    root: BinaryTreeNode<string | number>,\n    canvasElement: HTMLCanvasElement,\n    options: IndividualInputOptions,\n) {\n  // Initialization\n  const comp = new CanvasComponent(canvasElement);\n  globalPathArray = [];\n\n  /**\n   * Click event handler\n   */\n  comp.onClick((color) => {\n    globalPathArray = colorIdToPathMap.get(color) || globalPathArray;\n    requestAnimationFrame(root, comp, options);\n  });\n\n  /**\n   * Hover event handler\n   */\n  comp.onHover((color) => {\n    hoveredColorId = color;\n    requestAnimationFrame(root, comp, options);\n  });\n\n  // Draw frame\n  requestAnimationFrame(root, comp, options);\n}\n\nexport default drawExpandableBinaryTree;\n","import CanvasComponent from './Canvas';\nimport BinaryTreeNode from '../tree/BinaryTreeNode';\nimport theme from '../config/theme';\nimport {\n  getCanvasHeightFromTreeHeight,\n  getMaxLeafNodesFromHeight,\n  getRequiredAndActualHeightAndWidth,\n} from '../utils/tree';\nimport {\n  HorizontalStartAndEndInput,\n  IndividualInputOptions,\n} from './types';\nimport connectPointsWithBezierCurve\n  from '../utils/connectPointsWithBezierCurve';\n\n/**\n * Recursively draw all the nodes\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {CanvasComponent} canvasComponent\n * @param {number} currentLine\n * @param {HorizontalStartAndEndInput} horizontalConfig\n */\nfunction recursivelyDrawNodes(\n    root: BinaryTreeNode<string | number>,\n    canvasComponent: CanvasComponent,\n    currentLine: number,\n    horizontalConfig: HorizontalStartAndEndInput,\n) {\n  // X Calculation\n  const {xStart, xEnd} = horizontalConfig;\n  const xPosition = (xStart + xEnd) / 2;\n\n  // Y Calculation\n  const yPosition = currentLine * theme.lineHeight;\n\n  // Draw the node\n  root.nodeCircle.setCoordinates(xPosition, yPosition);\n  root.nodeCircle.draw(canvasComponent);\n\n\n  // Draw the left child nodes\n  // Radius is added and subtracted from y to move the line outside the circle\n  if (root.left) {\n    recursivelyDrawNodes(root.left, canvasComponent, currentLine+1, {\n      xStart,\n      xEnd: xPosition,\n    });\n    connectPointsWithBezierCurve(canvasComponent, {\n      xStart: xPosition,\n      xEnd: (xStart + xPosition) / 2,\n    }, {\n      yStart: yPosition + theme.radius,\n      yEnd: getCanvasHeightFromTreeHeight(currentLine + 1) - theme.radius,\n    });\n  }\n\n  if (root.right) {\n    recursivelyDrawNodes(root.right, canvasComponent, currentLine+1, {\n      xStart: xPosition,\n      xEnd,\n    });\n    connectPointsWithBezierCurve(canvasComponent, {\n      xStart: xPosition,\n      xEnd: (xPosition + xEnd) / 2,\n    }, {\n      yStart: yPosition + theme.radius,\n      yEnd: getCanvasHeightFromTreeHeight(currentLine + 1) - theme.radius,\n    });\n  }\n}\n\n/**\n * Draw an expandable binary tree\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {HTMLCanvasElement} canvasElement\n * @param {IndividualInputOptions} options\n */\nfunction drawSimpleBinaryTree(\n    root: BinaryTreeNode<string | number>,\n    canvasElement: HTMLCanvasElement,\n    options: IndividualInputOptions,\n) {\n  const heightOfTree = root.getHeight();\n  const maxNumberOfLeafNodes = getMaxLeafNodesFromHeight(heightOfTree);\n  const {maxHeight, maxWidth} = options;\n\n  // Max height and width requirements\n  const {\n    maxCanvasWidthRequired,\n    actualMaxHeight,\n    actualMaxWidth,\n  } = getRequiredAndActualHeightAndWidth(\n      maxNumberOfLeafNodes,\n      heightOfTree,\n      maxWidth,\n      maxHeight,\n  );\n\n  // Init calculation\n  const midPointInCanvas = actualMaxWidth / 2;\n  const xStart = (midPointInCanvas - maxCanvasWidthRequired / 2) +\n  theme.leafNodeSpace;\n  const xEnd = (midPointInCanvas + maxCanvasWidthRequired / 2) -\n  theme.leafNodeSpace;\n\n  // Initialize the canvas\n  const canvasComponent = new CanvasComponent(canvasElement);\n  canvasComponent.setMaxWidthAndHeight(actualMaxHeight, actualMaxWidth);\n\n  // Recursively draw the tree\n  recursivelyDrawNodes(root, canvasComponent, 0.5, {xStart, xEnd});\n}\n\nexport default drawSimpleBinaryTree;\n","import BinaryTreeNode from '../tree/BinaryTreeNode';\nimport {VisualizationType} from '../enumns/VisualizationType';\nimport drawPrettyBinaryTree from './drawPrettyBinaryTree';\nimport drawExpandableBinaryTree from './drawExpandableBinaryTree';\nimport drawSimpleBinaryTree from './drawSimpleBinaryTree';\nimport {MainInputOptions} from './types';\n\n\n/**\n * Draw a binary tree in one of the given types\n *\n * @param {BinaryTreeNode<string | number>} root\n * @param {HTMLCanvasElement} canvasElement\n * @param {Partial<MainInputOptions>} options\n */\nfunction drawBinaryTree(\n    root: BinaryTreeNode<string | number>,\n    canvasElement: HTMLCanvasElement,\n    options: Partial<MainInputOptions> = {},\n) {\n  const {\n    type = VisualizationType.SIMPLE,\n    maxHeight = window.innerHeight,\n    maxWidth = window.innerWidth,\n  } = options;\n\n  switch (type) {\n    case VisualizationType.PRETTY:\n      drawPrettyBinaryTree(root, canvasElement, {\n        maxHeight,\n        maxWidth,\n      });\n      break;\n\n    case VisualizationType.EXPANDABLE:\n      drawExpandableBinaryTree(root, canvasElement, {\n        maxHeight,\n        maxWidth,\n      });\n      break;\n\n    case VisualizationType.HIGHLIGHT:\n      drawPrettyBinaryTree(root, canvasElement, {\n        maxHeight,\n        maxWidth,\n        highlightMode: true,\n      });\n      break;\n\n    default:\n      drawSimpleBinaryTree(root, canvasElement, {\n        maxHeight,\n        maxWidth,\n      });\n      break;\n  }\n}\n\nexport default drawBinaryTree;\n","import CanvasComponent from './Canvas';\nimport drawBinaryTree from './drawBinaryTree';\n\nexport {\n  CanvasComponent,\n  drawBinaryTree,\n};\n","export * from './VisualizationType';\n","export * from './theme';\n","export * from './tree';\nexport * from './canvas';\nexport * from './enumns';\nexport * from './config';\n","import { BinarySearchTreeNode, drawBinaryTree, VisualizationType, setTheme } from 'binary-tree-visualizer';\r\nconst resultBtn = document.getElementById(\"btn\");\r\nconst nodesValues = document.getElementById(\"nodeData\");\r\nconst result = document.querySelector(\".result\");\r\nconst message = document.getElementById(\"suggest\");\r\nconst error = document.querySelector(\".error\");\r\nconst resetBtn = document.querySelector(\".reset\");\r\nsetTheme({\r\n  textFont: \"Poppins\",\r\n  radius: 31,\r\n  fontSize: 18,\r\n  strokeColor: \"#2a832f\",\r\n  colorArray: [\r\n    {\r\n      borderColor: \"#ffff\",\r\n      bgColor: \"#2a833f\",\r\n    },\r\n  ],\r\n  leafNodeSpace: 80,\r\n  lineHeight: 80,\r\n});\r\n\r\nresultBtn.addEventListener(\"click\", inputToList);\r\nresetBtn.addEventListener(\"click\", () => {\r\n  nodesValues.value = \"\";\r\n  message.innerText = \"\";\r\n  result.style.display = \"none\";\r\n  resetBtn.style.display = \"none\";\r\n});\r\nnodesValues.addEventListener(\"keyup\", (e) => {\r\n  if (e.key === \"Enter\") {\r\n    inputToList(e);\r\n  }\r\n});\r\nfunction inputToList(e) {\r\n  e.preventDefault();\r\n  if (nodesValues.value == \"\") {\r\n    error.style.display = \"block\";\r\n    result.style.display = \"none\";\r\n    message.innerText = \"\";\r\n    error.innerText = ` * Error: Please Enter Some Values , Tree Cannot Be Empty.`;\r\n    return;\r\n  } else {\r\n    result.style.display = \"flex\";\r\n    error.style.display = \"none\";\r\n    resetBtn.style.display = \"flex\";\r\n    const data = nodesValues.value.split(\" \");\r\n    const list = [];\r\n    data.forEach((values) => {\r\n      list.push(parseInt(values));\r\n    });\r\n    if (list.some(isNaN)) {\r\n      result.style.display = \"none\";\r\n      error.style.display = \"block\";\r\n      error.innerHTML =\r\n        \"Please Check All The Rules First , Only Numbers Are Allowed !!\";\r\n      return;\r\n    }\r\n\r\n    buildATree(list);\r\n    if (hasDuplicates(list)) {\r\n      const dupli = tellsDuplicates(list);\r\n      message.innerText =\r\n        \"YOUR FINAL BINARY SEARCH TREE : \\nYou Have Entered Some Duplicates Also : \";\r\n      dupli.forEach((elem) => {\r\n        message.innerText += \" \" + elem + \" ,\";\r\n      });\r\n    } else message.innerText = \"YOUR FINAL BINARY SEARCH TREE :\";\r\n  }\r\n}\r\nfunction buildATree(list) {\r\n  const root = new BinarySearchTreeNode(list[0]);\r\n  for (let i = 1; i < list.length; i++) {\r\n    root.insert(list[i]);\r\n  }\r\n  drawBinaryTree(root, document.querySelector(\"canvas\"));\r\n}\r\nfunction hasDuplicates(list) {\r\n  let set = new Set();\r\n  for (const i of list) set.add(i);\r\n  if (list.length != set.size) return true;\r\n  return false;\r\n}\r\nfunction tellsDuplicates(list) {\r\n  let res = new Set();\r\n  let counts = {};\r\n  for (const num of list) {\r\n    counts[num] = counts[num] ? counts[num] + 1 : 1;\r\n  }\r\n  for (const key in counts) {\r\n    if (Object.hasOwnProperty.call(counts, key)) {\r\n      if (counts[key] > 1) res.add(key);\r\n    }\r\n  }\r\n  return res;\r\n}\r\n\r\nif (window.matchMedia(\"screen and (max-width: 546px)\").matches) {\r\n  setTheme({\r\n    radius: 40,\r\n    leafNodeSpace: 110,\r\n    lineHeight: 110,\r\n  });\r\n}\r\n"]}